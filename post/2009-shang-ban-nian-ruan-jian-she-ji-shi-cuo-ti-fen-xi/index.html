<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title> 2009上半年软件设计师错题分析 | 亮仔的博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://syl2017.github.io//favicon.ico?v=1589355532155">
<link rel="stylesheet" href="https://syl2017.github.io//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="


海明码是一种多重（复式）奇偶检错编码
海明码的一项基本考虑是确定最少校验位数。若考虑位数k，考虑长度为n位的信息，若附加了k个校验位，则所发送的总长度为n+k。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果..." />
    <meta name="keywords" content="软件考试中级" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://syl2017.github.io/">
        <img src="https://syl2017.github.io//images/avatar.png?v=1589355532155" class="site-logo">
        <h1 class="site-title">亮仔的博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      转身从此陌生
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com" target="_blank">Gridea</a> | <a class="rss" href="https://syl2017.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title"> 2009上半年软件设计师错题分析</h2>
            <div class="post-date">2020-05-12</div>
            
            <div class="post-content" v-pre>
              <ol>
<li></li>
</ol>
<p>海明码是一种多重（复式）奇偶检错编码</p>
<p>海明码的一项基本考虑是确定最少校验位数。若考虑位数k，考虑长度为n位的信息，若附加了k个校验位，则所发送的总长度为n+k。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果可以表示成一个k位的二进制，他可以确定最多2<sup>k</sup>种不同状态。这些状态必有一个其所有奇偶测试都是真的，剩下2<sup>k</sup>-1中状态可以用来判定误码的位置  $ 2^k-1 \geqq n+k</p>
<p>2.硬盘容量分为非格式化容量和格式化容量</p>
<p>​	非格式化容量=面数*（磁道数/面） * 内圆周长 * 最大位密度</p>
<p>​	格式化容量 = 面数 * （磁道数/面） * （扇区数/道） * （字节数/扇区）</p>
<ol start="3">
<li></li>
</ol>
<p>存储器所处的位置可分为内存和外存</p>
<p>按构成原料的材料可分为磁存储器、半导体和光存储器</p>
<p>按工作方式可分为读写存储器和只读存储器</p>
<p>按访问方式可分为地址访问的存储器和按内容访问的存储器。</p>
<p>按寻址方式可分为随机存储器、顺序存储器和直接存储器</p>
<p>相连存储器是一种按内容访问的存储器</p>
<p>4.总线的分类</p>
<p>按总线上所传送的内容分为数据总线、地址总线和控制总线。</p>
<ol start="5">
<li></li>
</ol>
<p>移码表示法是X上增加一个偏移量来定义，常用于表示浮点数中的阶码。</p>
<p>机器字长为n时，在偏移量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的情况的情况下，只要将补码的符号位取反便可获得相应的移码表示。</p>
<ol start="6">
<li></li>
</ol>
<p>吞吐率和建立时间是使用流水线技术的两个重要指标</p>
<p>吞吐率是指单位时间里流水线处理机流出的结果数。</p>
<p>对指令而言，就是单位时间里执行的指令数。流水线开始工作时，需经过一定时间才能达到最大吞吐量从，这就建立时间。</p>
<p>若m个子过程所用时间一样，均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><mi>m</mi><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0 =m \Delta t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">m</span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ol start="7">
<li></li>
</ol>
<p>漏洞扫描系统的原理是根据系统漏洞库对系统可能存在的漏洞进行一一验证。</p>
<p>黑客利用漏斗扫描系统可以发现目标主机的安全漏洞从而有针对的对系统发起攻击；</p>
<p>系统管理利用漏洞扫描系统可以查找系统中存在的漏洞进行修补从而提高系统的可靠性。漏洞扫描系统不能用于发现网络乳清这，用于检测网络乳清这的系统称为如入侵检测系统。</p>
<ol start="8">
<li></li>
</ol>
<p>数字签名技术是不对称加密算法的典型应用。</p>
<p>数据发送发使用自己的私钥对数据校验和其他与数据内容有关的变量进行加密处理，完成对数据的合法“签名”；</p>
<p>数据接受方则利用对方的公钥来解读收到的“数字签名”；</p>
<p>数字签名是对签名真实性的保护</p>
<ol start="10">
<li></li>
</ol>
<p>软件著作权采用“自动保护”原则。</p>
<p>软件著作权自软件开发完成之日产生。</p>
<ol start="12">
<li></li>
</ol>
<p>声音的频率是指声波每秒钟变化的次数，用Hz表示。</p>
<p>人们把频率小于20Hz的声波信号称为亚音信号；</p>
<p>频率范围为20Hz~20kHz的声波信号称为音频型号；</p>
<p>高于20Khz的信号称为超音频信号（超声波）</p>
<ol start="13">
<li></li>
</ol>
<p>JPEG是一个适用范围很广的静态图像数据压缩标准，即可用于灰度图像又可用彩色图像。</p>
<p>MPEG文件格式运动图像压缩算法的国际标准，包括MPEG视频、MPEG音频和MPEG系统三个部分。</p>
<p>AVI是Microsoft公司开发的一种符合RIFF文件规范的数字音频的数字音频与视频文件格式。</p>
<ol start="14">
<li></li>
</ol>
<p>P59</p>
<p>计算机获取模拟信息的过程中首先要进行|A/D变换|。</p>
<ol start="15">
<li></li>
</ol>
<p>敏捷方法进行软件开发。</p>
<p>重构是中重新组织技术，重新审视需求和设计，重新明确地描述他们以符合新的和现有的需求，可以简化构件的设计而无须改变其功能或行为。</p>
<ol start="16">
<li></li>
</ol>
<p>RUP对软件开发过程的描述。RUP应用了角色、活动、制品和工作流4种重要的模型元素。其中角色表述“谁做”，制品表述“做什么”，活动表述“怎么做”，工作流表述“什么时候做”。</p>
<p>-&gt; 2010上半年设计师  第18题PERT</p>
<ol start="17">
<li></li>
</ol>
<p><strong>软件风险</strong>一般包括<strong>不确定性</strong>和<strong>损失</strong>两个<strong>特性</strong></p>
<p>不确定性是指风险可能发生，也可能不发生；</p>
<p>损失是当风险确实发生时，会引发的不希望的后果和损失。</p>
<p>救火和危机管理是对不适合但经常采用的<strong>软件风险管理策略</strong>*。</p>
<p>已知风险和未知风险是对<strong>软件风险进行分类</strong>的一种方式。</p>
<p>员工和预算是在识别<strong>软件风险需要识别的因素</strong>。</p>
<ol start="21">
<li></li>
</ol>
<p>反编译通常不能把可执行文件还原成高级语言源代码，只能转化成功能上等价的汇编程序。</p>
<ol start="25">
<li></li>
</ol>
<p>先来先服务是谁先请求先满足谁的请求，而最短寻找时间优先是根据当前磁臂到要请求访问磁道的距离，谁短满足谁的请求，故先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运动方向。</p>
<ol start="26">
<li></li>
</ol>
<p>死锁，系统同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。</p>
<ol start="28">
<li></li>
</ol>
<p>CMM的基本概念。</p>
<p>建立基本的项目管理和实践来跟踪项目费用、进度和功能特性为<strong>可重复级的核心</strong>；</p>
<p>使用标准开发过程构件系统为<strong>已定义级的核心</strong>；</p>
<p>管理层寻求更主动地对应系统的开发问题为<strong>已管理级的核心</strong>；</p>
<p>连续地监督和改进标准化的系统开发过程为<strong>优化级的核心</strong>。</p>
<ol start="30">
<li></li>
</ol>
<p>RUP每个阶段产生的制品</p>
<p><strong>初启阶段</strong>结束时产生一个构想文档、一个有关用例模型的调查、一个初始的业务用例、一个早期的风险评估和一个可以显示阶段和迭代的项目计划等制品；</p>
<p><strong>精华阶段</strong>结束时产生一个补充需求分析、一个软件架构描述和一个可执行的架构原型等制品；</p>
<p><strong>构建阶段</strong>结束时的成果是一个准备交到最终用户手中的产品，包括最具有最初运作能力的在适当的平台上集成的软件产品、用户手册和对当前版本的描述</p>
<p><strong>移交阶段</strong>结束时产生移交给用户产品发布版本。</p>
<ol start="31">
<li></li>
</ol>
<p>ISO/IEC 9126 软件质量度量模型中的质量特性。效率质量特性包括时间特性和资源特性两个质量子特性。</p>
<ol start="32">
<li></li>
</ol>
<p>McCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，他基于一个程序模块的程序吐中环路的个数。计算有向图G的环路复杂性的公式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>(</mo><mi>G</mi><mo>)</mo><mo>=</mo><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">V(G)=m-n+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>,其中V（G）是有向图G中的环路个数，m是G中的有向弧数，n是G中的节点数。</p>
<ol start="33">
<li></li>
</ol>
<p>开发文档。</p>
<p>系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划、系统开发月报以及系统开发总结报告等项目管理文件。</p>
<p>34.软件维护</p>
<p>P281</p>
<p>软件维护</p>
<p>1.正确性维护。改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</p>
<p>2.适应性维护。适应性维护是指应用软件适应信息技术变化和管理需求变化而进行的修改。</p>
<p>3.完善性维护，这是为扩充功能和改善性能而进行的修改，主要是对指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</p>
<p>4.预防性维护。为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬环境的变化，应主动增加预防性的新的功能。</p>
<p>38-40.</p>
<p>P352</p>
<p>类可以分为三种：实体类、接口类（边界类）和控制类。</p>
<p>实体类的对象表示现实世界中真实的实体。</p>
<p>接口类（边界类）的对象为用户提供一种与系统合作交互的方式。</p>
<p>控制类的对象用来控制活动流，充当协调者。</p>
<ol start="41">
<li></li>
</ol>
<p>2010年上半年错题分析-----&gt;41.</p>
<p>43-45.</p>
<p>装饰模式主要的目的是在无法生成子类的情况下给一个对象动态地增加新的职责；</p>
<p>享元设计模式是共享大量细粒度的对象；</p>
<p>适配器设计模式则是将已有的借口转换为系统希望的借口形式。</p>
<ol start="50">
<li></li>
</ol>
<p>一个文法的语言是该文法能产生的句子的集合。</p>
<p>一个文法产生的句子是从文法开始符号出发推导出的所有终结符号串。</p>
<ol start="51">
<li></li>
</ol>
<p>P473</p>
<p>常见的数据模型有层次模型、网状模型、关系模型和面向对象模型。</p>
<p>(1).层次模型 采用树型结构表示数据与数据见得联系。</p>
<p>(2).网状模型 允许两个结点之间有多种联系（称之为复合联系）。</p>
<p>(3).关系模型 关系数据库系统采用关系模型作为数据的组织方式，表达实体集以及实体集之间的联系</p>
<p>(4).面向对象数据模型 面向对象的方式来设计数据库。</p>
<ol start="52">
<li></li>
</ol>
<p>分解的模式是否与原来的模式等价</p>
<ul>
<li>分解具有无损连接性</li>
<li>分解要保持函数依赖</li>
<li>分解既要无损连接性，又要保持函数依赖。</li>
</ul>
<p>55-56.</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mn>1</mn><mo>&lt;</mo><mn>6</mn></mrow></msub><mo>(</mo><mi>R</mi><mo>×</mo><mi>S</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">集</mi></mrow><annotation encoding="application/x-tex">\pi_{3,4,5}(\sigma_{1&lt;6}(R\times S))的结果集
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">&lt;</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">集</span></span></span></span></span></p>
<p><strong>广义笛卡尔积（Extended Cartesian Product)</strong></p>
<p>现有关系R和关系S，如下表所示。</p>
<p><strong>关系R</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
</tbody>
</table>
<p><strong>关系S</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
</tbody>
</table>
<p>先求关系R和关系S的广义笛卡儿积RxS。</p>
<p><strong>RxS</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">R.A</th>
<th style="text-align:left">R.B</th>
<th style="text-align:left">R.C</th>
<th style="text-align:left">S.A</th>
<th style="text-align:left">S.B</th>
<th style="text-align:left">S.C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
</tbody>
</table>
<p><strong>选择（Selection）</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mn>1</mn><mo>≥</mo><mn>6</mn></mrow></msub><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{1\geq6}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≥</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>表示选取R关系中第一个属性值大于等于第六个属性的元组。</p>
<p><strong>投影（Projection）</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mi>A</mi></msub><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi_A(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>在关系R中选择若干属性列A组成新的关系。</p>
<ol start="57">
<li></li>
</ol>
<p>哈希表和二叉排序树都可以在查找过程中动态创建，属于动态查找表。</p>
<p>顺序查找表方法按照设定的次序依次与查找表中元素的关键字进行比较，在顺序存储结构和链表结构上都可以实现该查找过程。</p>
<p>二分查找需要对中间元素进行快速定位，在链表结构上无法实现。</p>
<ol start="58">
<li></li>
</ol>
<p>有向图中，若以顶点表示活动，用有向边表示活动之间的优先关系，则称这样的有向图为以顶点表示活动的网（Activity On Vertex Network，AOV）</p>
<p>若在带权有向图G中以顶点表示事件，以有向边表示活动，边上的权值表示该活动持续的时间，则这种带权有向图称为用边表示活动的图（Activity On Edge Network,AOE网）</p>
<p>通常AOE网中列出了完成预定工程计划所需进行的活动、每项活动的计划完成时间、要发生哪些事件以及这些事件和活动间的关系，从而可以分析该项工程是否实际可行并估计工程完成的最短时间，分析哪些活动是影响工程进度的关键。进一步进行人力、物力的调度和分配，以达到缩短工期的目的。</p>
<p>根据生成树的定义，有n个顶点的连通图的生成树恰好有n-1条边。</p>
<ol start="59">
<li></li>
</ol>
<p>二叉排序树具有如下性质：</p>
<ol>
<li>若它的左子树非空，则其左子树上所有节点的关键字均小于根节点的关键字。</li>
<li>若它的右子树非空，则其右子树上所有节点的关键字均大于根节点的关键字。</li>
<li>左、右子树本身就是两颗二叉排序树。</li>
</ol>
<p>二叉排序树是一个有序表，对二叉排序树进行中序遍历，可得到一个关键字递增排序的序列。</p>
<p>构造一颗二叉排序树：从空树开始，每读入一个关键字值，就建立一个新结点。若二叉树非空，则将新结点的关键字与根节点的关键字相比较，如果小于根节点的值，则插入到左子树中，否则插入到右子树中；若二叉排序树为空树，则新结点作为二叉排序树的根节点。</p>
<p>若关键字序列已经有序，则构造出的二叉排序树一定是单枝树。</p>
<p>为了使在二叉排序树上进行的查找操作性能最优，构造二叉排序树需进行平衡化处理，使每个结点左、右子树高度差的绝对值不超过1。</p>
<ol start="60">
<li></li>
</ol>
<p>栈和队列都是操作受限的线性表：栈仅在表尾插入和删除元素，队列仅在表头删除元素、在表尾插入元素。</p>
<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200511202102.png" alt="用线性表模拟入队操作" loading="lazy"></figure>
<ol>
<li>
<p>入队时，新元素在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，若新元素节点指针为s，则在一般情况下入队操作序列表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">s\rightarrow next=rear\rightarrow next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span>; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">rear\rightarrow next=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">rear=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>;</p>
</li>
<li>
<p>出队时，讲队头元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>从队列中删除，一般情况下出队操作序列表示为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo separator="true">;</mo><mspace linebreak="newline"></mspace><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>=</mo><mi>q</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mspace linebreak="newline"></mspace><mi>f</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q=rear\rightarrow next;\\rear \rightarrow next=q \rightarrow next \\free(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200511202103.png" alt="用线性表模拟出队操作" loading="lazy"></figure>
<p>入队时初始化队列为空、出队后队列变为空要进行特殊处理。</p>
<p>入队操作和出队操作均匀队列长度无关，因此时间复杂度都为O(1).</p>
<p>一个线性序列经过队列结构后只能得到与原序列相同的元素序列，而经过一个栈结构后则可以得到多种元素序列。</p>
<p>用两个栈可以模拟一个队列的入队和出队操作。</p>
<ol start="61">
<li></li>
</ol>
<p>一颗完全二叉树除了最后一层外，其他层的节点都是满的，最后一层的节点也必须自左至右排列。</p>
<p>二叉树采用顺序存储结构时，对于编号为i的节点，则有：</p>
<ul>
<li>若i=1时，该节点为根节点，无双亲；</li>
<li>若i&gt;1时，该节点的双亲节点为「i/2」;</li>
<li>若2i<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≦</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\leqq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mrel amsrm">≦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,则节点的双亲节点为2i，否则无左孩子；</li>
<li>若2i+1<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≦</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\leqq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mrel amsrm">≦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,则该节点的则该节点的右孩子编号为2i+1，否则无右孩子。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200511202104.png" alt="" loading="lazy"></figure>
<p>可以推到出具有n个节点的完全二叉树的深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">log_2 n +1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>62.广义表是函数式语言中使用的一种数据结构。根据广义表取表头和取表尾的定义，对于广义表L=((x,y,z),a,(u,t,w)),运算head(L)定义为取非空广义表的第一个元素，tail(L)定义为取非空广义表第一个元素剩余元素构成的广义表。</p>
<ol start="64">
<li></li>
</ol>
<p>回溯法的实质是在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。若进入某子节点的子树后没有找到解（或者需要找到全部解），则需要子节点回退（回溯）至父节点，从而选择其他节点进行搜索。</p>
<p>分治与递归就像一对孪生兄弟，经常同时应用与算法设计之中。分治的思路是将一个难以直接解决的大问题分解成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的，如用分治法来解这类问题，则相同的子问题会不会求解多次，以至于最后的解决原问题需要耗费支出及时间，动态规划算法通常用于求解具有某种最优性质的问题，在这类问题中可能会有许多可行解。每个可行解都对应一个值，我们希望找到具有最优值的那个解。</p>
<p>67.Server2003，路由类型有五种。当windows服务器收到一个ip数据包是先查主机路由，在查网络路由直连网络和远程网络这些路由查找失败时，最后才查找默认路由。</p>
<table>
<thead>
<tr>
<th>路由类型。</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>直连网络id，</td>
<td>用于直连的网络interfaith可以为空。</td>
</tr>
<tr>
<td>远程网络id</td>
<td>用于不直接连接的网络可以通过其他路由器到达这种网络，interfaith字段是本地路由器的ip地址。</td>
</tr>
<tr>
<td>主机路由。</td>
<td>到达特定的主机，路由子网掩码为255.255.255.255。</td>
</tr>
<tr>
<td>默认路由。</td>
<td>无法找到确定路由时使用的路由目标网络和网络掩码都是0.0.0.0。</td>
</tr>
<tr>
<td>持久路由</td>
<td>利用route add -p命令添加的表现，每次初始化时，这种路由都会加入windows的注册表中，同时加入路由表。</td>
</tr>
</tbody>
</table>
<p>68.HTML基本标签的使用alink用于设置正在比鸡种的链接的颜色vlink用于设置使用的链接的颜色background，用于设置背景图片的URL bgcolor用于设置文档整体背景颜色。</p>
<p>69.HTML标记中tr标记的使用。&lt;tr&gt;标记用于定义表格中的一行。&lt;col&gt;标记用于定义表格中一个或多个列的属性值。&lt;td&gt;标记定义表格中的一个单元格。</p>
<p>70.XML语法的基本知识，XML文件的第一行必须是声明该文件是XML文件以及它所使用的XML规范版本，在文件的前面并能够有其他元素或是注释，所有的XML文件必须有一个根元素，XML文件的第一个元素就是根元素。所有XML文档都必须包含一个单独的标记来定义所有其他元素都必须成对的，在根元素嵌套XML文件有且只能有一个根元素，所有的元素都可以有子元素，子元素必须正确地嵌套在父元素中来，在XML中规定所有标志必须成对出现有一个开始标识，就必须有一个结束标志，否则就将被视为错误。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://syl2017.github.io/tag/Ma0goush1/" class="tag">
                    软件考试中级
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://syl2017.github.io/post/5chou-xiang-gong-han/">
                  <h3 class="post-title">
                    5.抽象工厂
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
