<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://syl2017.github.io/</id>
    <title>亮仔的博客</title>
    <updated>2020-05-12T01:08:29.087Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://syl2017.github.io/"/>
    <link rel="self" href="https://syl2017.github.io/atom.xml"/>
    <subtitle>转身从此陌生</subtitle>
    <logo>https://syl2017.github.io/images/avatar.png</logo>
    <icon>https://syl2017.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 亮仔的博客</rights>
    <entry>
        <title type="html"><![CDATA[面向对象设计原则]]></title>
        <id>https://syl2017.github.io/post/mian-xiang-dui-xiang-she-ji-yuan-ze/</id>
        <link href="https://syl2017.github.io/post/mian-xiang-dui-xiang-she-ji-yuan-ze/">
        </link>
        <updated>2020-05-12T01:03:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="面向对象原则">面向对象原则</h1>
<p>OOD</p>
<p>面向对象设计OOD</p>
<ul>
<li>
<p>单一职责原则（Singel-Responsibility Principe）</p>
</li>
<li>
<p>开放式封闭原则（Open-Colesd Pinciple）</p>
</li>
<li>
<p>里氏替换原则 （Liskov Substitution Principe）</p>
</li>
<li>
<p>依赖倒置原则 （Dependence Inversion Principle)</p>
</li>
<li>
<p>借口隔离原则 (Interface Segregation Principle)</p>
</li>
<li>
<p>迪米特原则  (Law of Demeter)</p>
</li>
</ul>
<p><strong>单一职责原则（SRP）</strong></p>
<p>一个类而言，应该只负责一个功能。</p>
<p>高内聚</p>
<p>好处</p>
<p>1.降低负责度</p>
<p>2.负责度低</p>
<p>3.可维护性高。</p>
<p>原先的模式</p>
<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99A%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>之后的剥离的模式</p>
<figure data-type="image" tabindex="2"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99B%E5%9B%BE.png" alt="单一职责原则B图" loading="lazy"></figure>
<p>代码修改之后<img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99D%E5%9B%BE.jpeg" alt="单一职责原则D图" loading="lazy"></p>
<p><strong>开放-封闭原则</strong></p>
<p>高内聚，低耦合。</p>
<p>软件实体应尽量不修改原有代码的情况下进行扩展。</p>
<p>原来的模式</p>
<figure data-type="image" tabindex="3"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99A%E5%9B%BE.JPG" alt="开放封闭原则A图" loading="lazy"></figure>
<p>之后的模式</p>
<figure data-type="image" tabindex="4"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99B%E5%9B%BE.JPG" alt="开放封闭原则B图" loading="lazy"></figure>
<p>代码实现 （之前）</p>
<figure data-type="image" tabindex="5"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99C%E5%9B%BE.jpg" alt="开放封闭原则C图" loading="lazy"></figure>
<p>修改之后的代码<img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99D%E5%9B%BE.jpg" alt="开放封闭原则D图" loading="lazy"></p>
<p><strong>里氏替换原则</strong></p>
<p>子类型能够替换基类型。基类对象和子类对象区别不大。</p>
<p>低耦合</p>
<p>原来的模式</p>
<figure data-type="image" tabindex="6"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99A%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>之后的模式</p>
<figure data-type="image" tabindex="7"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99B%E5%9B%BE.jpg" alt="" loading="lazy"></figure>
<p>代码1</p>
<figure data-type="image" tabindex="8"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99C%E5%9B%BE.JPEG" alt="" loading="lazy"></figure>
<p>代码2</p>
<figure data-type="image" tabindex="9"><img src="" alt="" loading="lazy"></figure>
<p><strong>依赖倒置原则</strong></p>
<p>依赖于抽象，不要与具体。</p>
<p>低耦合</p>
<p>原来的模式</p>
<figure data-type="image" tabindex="10"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99A%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>现在的模式</p>
<figure data-type="image" tabindex="11"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99B%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>代码1</p>
<figure data-type="image" tabindex="12"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99C%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>代码2</p>
<figure data-type="image" tabindex="13"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99D%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p><strong>接口隔离原则</strong>（ISP）</p>
<p>使用多个专一功能的借口比使用一个的总借口总要好。</p>
<p>高内聚</p>
<p>原来的模式</p>
<figure data-type="image" tabindex="14"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99A%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>修改后</p>
<figure data-type="image" tabindex="15"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99B%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>代码1</p>
<figure data-type="image" tabindex="16"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99C%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>代码2</p>
<figure data-type="image" tabindex="17"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99D%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>迪米特法则</p>
<p>最少知识原则</p>
<p>低耦合</p>
<p>对象与对象之间应该使用可能少的方法来关联，避免千丝万缕的关系</p>
<p>类知道的其他的类应该尽量少</p>
<p>原来的模式</p>
<figure data-type="image" tabindex="18"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99A%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>修改的模式</p>
<figure data-type="image" tabindex="19"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99B%E5%9B%BE.JPG" alt="" loading="lazy"></figure>
<p>代码1</p>
<figure data-type="image" tabindex="20"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99C%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>代码2</p>
<figure data-type="image" tabindex="21"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99D%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p><strong>设计模式</strong>（Design Pattern）</p>
<h5 id="创建类模式高效地创建对象">创建类模式（高效地创建对象）</h5>
<ul>
<li>简单工厂模式(Simple Factory)</li>
<li>工厂方法模式(Factory Method)</li>
<li>抽象工厂模式(Abstract Factory)</li>
<li>创建者模式(Builder)</li>
<li>原型模式(Prototype)</li>
<li>单例模式(Singleton)</li>
</ul>
<h5 id="结构型模式对象的结构关系">结构型模式（对象的结构关系）</h5>
<ul>
<li>外观模式(Facade)</li>
<li>适配器模式(Adapter)</li>
<li>代理模式(Proxy)</li>
<li>装饰模式(Decorator)</li>
<li>桥接模式(Bridge)</li>
<li>组合模式(Composite)</li>
<li>享元模式(Flyweight)</li>
</ul>
<p>行为型模式（对象的行为）</p>
<ul>
<li>模板方法模式（Template Method）</li>
<li>观察者模式（Observer）</li>
<li>状态模式（State）</li>
<li>策略模式（Strategy）</li>
<li>职责链模式（Chain of Responsibility)</li>
<li>命令模式(Command)</li>
<li>访问者模式(Visitor)</li>
<li>中介者模式(Mediator)</li>
<li>备忘录模式(Memento)</li>
<li>迭代器模式(Iterator)</li>
<li>解释器模式(Interpreter)</li>
</ul>
<h5 id="1单例模式"><strong>1.单例模式</strong></h5>
<p>保证一个类仅有一个实例，并提供一个访问他的全局访问点。</p>
<p>成员：静态的实例</p>
<p>方法：1.私有构造 2.静态的获取实例方法</p>
<figure data-type="image" tabindex="22"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FA%E5%9B%BE.jpg" alt="" loading="lazy"></figure>
<p>创建分类</p>
<ul>
<li>饿汉式：（Hungry）
<ul>
<li>类加载时创建</li>
<li>优点
<ul>
<li>线程安全</li>
</ul>
</li>
<li>缺点
<ul>
<li>过早浪费资源</li>
</ul>
</li>
</ul>
</li>
<li>懒汉式：（Lazy）
<ul>
<li>在使用时做判断</li>
<li>优点
<ul>
<li>使用时候才创建，节约资源</li>
</ul>
</li>
<li>缺点
<ul>
<li>为线程安全付出额外代价</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="23"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FB%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>第一步：验证饥饿和懒惰的线程安全</p>
<p>饥饿式通过结果可看到：可保证线程安全</p>
<figure data-type="image" tabindex="24"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8A%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>懒汉式通过结果可看到无法保证单例模式的正确</p>
<figure data-type="image" tabindex="25"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8B%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>以下对懒汉式的改进</p>
<p>1.对getInstance方法加锁 即synchronized</p>
<p>2.加锁的加强版双重判断 先判断对象是否存在 再给类加锁，之后再一次判断是否为空，给成员对象加volatile关键字。</p>
<figure data-type="image" tabindex="26"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8C%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>3.使用内部类</p>
<figure data-type="image" tabindex="27"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8D%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<h5 id="2工厂模式">2.工厂模式</h5>
<p>属于创新型设计模式，通过专门定义一个类来负责其他类的实例。</p>
<figure data-type="image" tabindex="28"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FA%E5%9B%BE.jpg" alt="" loading="lazy"></figure>
<p>工厂角色：负责创建所有逻辑，创建所需对象。</p>
<p>抽象产品角色：所有对象的父类，也可为借口或抽象类。</p>
<p>具体产品：拥有共同父类。</p>
<p>代码实现</p>
<figure data-type="image" tabindex="29"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FB%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>优点</p>
<p>根据外界的信息，决定创建那个具体类的对象。用户使用直接创建所需的实例，而无需了解这些对象如何创建以及组织。</p>
<p>缺点</p>
<p>工厂类集中了所有实例的创建逻辑，违背了单一职责，违背了开放封闭原则。</p>
<h5 id="4工厂方法">4.工厂方法</h5>
<p>定义一个创建对象的接口，让其子类决定实例化哪一个类。</p>
<figure data-type="image" tabindex="30"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95A%E5%9B%BE.jpg" alt="" loading="lazy"></figure>
<p>工厂借口：与调用者交互来提供产品</p>
<p>工厂实现：工厂决定如何实例化产品，有多少种产品，就需要多少个具体的工厂实现。</p>
<p>产品借口：定义产品规范</p>
<p>产品实现：实现产品借口的具体类。</p>
<figure data-type="image" tabindex="31"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95B%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>优点：用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</p>
<p>缺点：每次增加一个产品，都需要增加一个具体和对象实现工厂。是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加具体类的依赖。</p>
<h5 id="抽象工厂">抽象工厂</h5>
<p>多个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类；每个具体工厂类可创建多个具体产品类的实例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UML简介与入门]]></title>
        <id>https://syl2017.github.io/post/uml-jian-jie-yu-ru-men/</id>
        <link href="https://syl2017.github.io/post/uml-jian-jie-yu-ru-men/">
        </link>
        <updated>2020-05-12T00:47:05.000Z</updated>
        <content type="html"><![CDATA[<p>UML是Unified Modeling language(UML) 称为统一建模语言或标准建模语言，支持模型化和软件系统开发的图形化语言。</p>
<h5 id="分类两类">分类（两类）</h5>
<ul>
<li>结构型的图（Structure Diagram）</li>
</ul>
<ol>
<li>类图(Class  Diagram)</li>
<li>对象图(Object Diagram)</li>
<li>构件图(Component Diagram)</li>
<li>部署图(Deployment Diagram)</li>
<li>包图（Package Diagram）</li>
</ol>
<ul>
<li>行为型的图（Behavior Diagram)</li>
</ul>
<ol>
<li>
<p>活动图(Activity Digram)</p>
</li>
<li>
<p>状态机图(State Machine Diagram)</p>
</li>
<li>
<p>顺序图(Sequence Diagram)</p>
</li>
<li>
<p>通信图(Communication Diagram)</p>
</li>
<li>
<p>用例图(Use Case Diagram)</p>
</li>
<li>
<p>时序图（Timing Diagram）</p>
</li>
</ol>
<h5 id="类图">类图</h5>
<p>矩形框代表一个类，类图分为三层</p>
<ul>
<li>第一层显示类的名</li>
<li>第二层是类的特性 （成员变量和属性）</li>
<li>第三层是类的操作，通常就是方法或是函数</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/Main.jpg" alt="Main" loading="lazy"></figure>
<p><strong>修改属性和方法</strong></p>
<p>​	访问权限：</p>
<ul>
<li>​		‘+’ 表示public</li>
<li>​		'-'表示private</li>
<li>​		‘#’表示protected</li>
<li>​		‘~’表示package</li>
</ul>
<p>​	其他关键字</p>
<ul>
<li>​		下划线表示static</li>
<li>​		斜体表示abstract</li>
</ul>
<p>冒号（：）</p>
<p>​	表示成员变量类型</p>
<p>​	表示方法返回值</p>
<p>等号（=）</p>
<p>​	表示默认值</p>
<p>方法的参数表示与类成员变量表示方法完全相同</p>
<p><strong>接口</strong></p>
<p>两种表现形式</p>
<ol>
<li>圆圈</li>
<li>名字上带有《interface》，方便接口展示方法</li>
</ol>
<h5 id="类与类之间的关系6种">类与类之间的关系（6种）</h5>
<p>​	类与继承泛化（Generalization)</p>
<p>【泛化关系】	是一种继承关系，表示一般与特殊的关系。</p>
<p>【箭头指向】到三角箭头的实线，箭头指向父类</p>
<p>【代码表现】为extends</p>
<figure data-type="image" tabindex="2"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E6%B3%9B%E5%8C%96.PNG" alt="" loading="lazy"></figure>
<p>接口与实现（Realization）</p>
<p>【实现关系】是类与接口的关系，类是接口的实现</p>
<p>【箭头指向】：带三角箭头的虚线箭头指向接口或是直线连接圆圈</p>
<p>【代码实现】：最典型的就是implements</p>
<p>依赖（Dependency)</p>
<p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，尽量不使用双向依赖</p>
<p>【代码表现】：import</p>
<figure data-type="image" tabindex="3"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E4%BE%9D%E8%B5%96.PNG" alt="" loading="lazy"></figure>
<p>关联（Association）</p>
<p>【关联关系】是一种拥有的关系，一个类知道另外一个类的属性和方法</p>
<p>【代码体现】：成员变量</p>
<p>【箭头及指向】：带普通箭头的实心线，指向被拥有者。双向的关联可以有两个箭头或者没有箭头</p>
<figure data-type="image" tabindex="4"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%85%B3%E8%81%94.PNG" alt="" loading="lazy"></figure>
<p>聚合（Aggregation）</p>
<p>【聚合关系】：是整体与部分的关系，且部分离开整体而可以单独存在</p>
<p>【代码体现】：成员变量</p>
<p>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p>
<figure data-type="image" tabindex="5"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E8%81%9A%E5%90%88.PNG" alt="" loading="lazy"></figure>
<p>组合（Composition）</p>
<p>​	【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。</p>
<p>【代码体现】：成员变量</p>
<p>【箭头及指向】：带实心菱形的实现，菱形指向整体</p>
<figure data-type="image" tabindex="6"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E7%BB%84%E5%90%88.PNG" alt="" loading="lazy"></figure>
<p>类关系强弱对比</p>
<p>泛化=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p>
<p>聚合关系是关联关系的一种，部分与整体的生命周期不一定相同</p>
<p>关联只是表示两个类之前有交互<br>
依赖完全与生命周期无关</p>
]]></content>
    </entry>
</feed>