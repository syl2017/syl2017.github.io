<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://syl2017.github.io/</id>
    <title>亮仔的博客</title>
    <updated>2020-05-12T08:01:15.886Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://syl2017.github.io/"/>
    <link rel="self" href="https://syl2017.github.io/atom.xml"/>
    <subtitle>转身从此陌生</subtitle>
    <logo>https://syl2017.github.io/images/avatar.png</logo>
    <icon>https://syl2017.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 亮仔的博客</rights>
    <entry>
        <title type="html"><![CDATA[苹果键盘对应的Win键盘]]></title>
        <id>https://syl2017.github.io/post/ping-guo-jian-pan-dui-ying-de-win-jian-pan/</id>
        <link href="https://syl2017.github.io/post/ping-guo-jian-pan-dui-ying-de-win-jian-pan/">
        </link>
        <updated>2020-05-12T08:00:23.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200512160043.PNG" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一章 Python 基础]]></title>
        <id>https://syl2017.github.io/post/di-yi-zhang-python-ji-chu/</id>
        <link href="https://syl2017.github.io/post/di-yi-zhang-python-ji-chu/">
        </link>
        <updated>2020-05-12T07:53:22.000Z</updated>
        <content type="html"><![CDATA[<p>1.1在交互环境中输入表达式</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2011上半年软件设计师上午试题分析与解答]]></title>
        <id>https://syl2017.github.io/post/2011-shang-ban-nian-ruan-jian-she-ji-shi-shang-wu-shi-ti-fen-xi-yu-jie-da/</id>
        <link href="https://syl2017.github.io/post/2011-shang-ban-nian-ruan-jian-she-ji-shi-shang-wu-shi-ti-fen-xi-yu-jie-da/">
        </link>
        <updated>2020-05-12T07:52:00.000Z</updated>
        <content type="html"><![CDATA[<p>23-24.</p>
<p>位示图</p>
<p><strong>系统的字长为32位</strong>。磁盘上的物理块依次编号为0、1、2···，那么<strong>4096号</strong>物理块的使用情况在位示图中的第___个字描述。</p>
<p>0~31 为第一个字</p>
<p>32-63 为第二个字</p>
<p>··· ···</p>
<p>4064~4095 为第128个字</p>
<p>4096~4127号129个字</p>
<p>（4096+32）/32=129</p>
<p>若硬盘的容量为200GB，物理块的大小为1MB，那么位示图的大小为__个字。</p>
<p>磁盘中的物理块为（200*1024）MB/1MB=2048000个物理块。</p>
<p>2048000/32=6400个</p>
<ol start="29">
<li></li>
</ol>
<p>瀑布模型从一种非高层的角度描述了软件开发过程中进行的活动，该模型使用于项目。</p>
<p>V模型是瀑布模型的变种，测试活动是如何与分析和设计相联系的。原型模型允许开发人员快速地构造整个系统或系统的一部分以理解或澄清问题。</p>
<p>原型模型可以有效地引发系统需求。</p>
<p>螺旋模型把开发活动和风险管理结合起来，以风险捡到最小并控制风险。</p>
<ol start="30">
<li></li>
</ol>
<p>过程改进</p>
<p>软件质量依赖于软件开发过程的质量，其中，人的因素是主导的，开发技术、过程质量、成本时间和进度也是影响因素。</p>
<p>要使得过程改进有效，需要制定过程改进的目标，还需要对开发人员进行培训。</p>
<p>CMMI是构成为“集成模型”，即成熟度模型，该模型支持阶段性过程改进和连续性过程改进。</p>
<p>31-32.</p>
<p>软件可靠性指的是一个系统对于给定的时间间隔内，在给定条件下无失效运行的概率。</p>
<ol start="33">
<li></li>
</ol>
<p>文档的特性</p>
<p>针对性：文档编制应当考虑读者</p>
<p>精确性：文档的行文应该十分确切</p>
<p>清晰性：文档编写应力求简明</p>
<p>完整性：任何文档都应当时完整的、独立的、应该自称体系</p>
<p>灵活性：不同项目，规模和复杂度有实际差别</p>
<p>可追溯性：前后两个阶段生成的文档具有一定的继承关系。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2010下半年软件设计师错题分析]]></title>
        <id>https://syl2017.github.io/post/2010-xia-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/</id>
        <link href="https://syl2017.github.io/post/2010-xia-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/">
        </link>
        <updated>2020-05-12T07:51:30.000Z</updated>
        <content type="html"><![CDATA[<p>2010下半年软件设计师错题分析</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2010上半年软件设计师错题分析]]></title>
        <id>https://syl2017.github.io/post/2010-shang-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/</id>
        <link href="https://syl2017.github.io/post/2010-shang-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/">
        </link>
        <updated>2020-05-12T07:50:31.000Z</updated>
        <content type="html"><![CDATA[<h4 id="上午">（上午）</h4>
<p>1.（P3）指令寄存器IR用来保存当前正在执行的指令。</p>
<p>地址寄存器（AR）用来保存当前CPU所访问的内存单元的地址</p>
<p>由于在内存和CPU之间存在操作速度上的差别</p>
<p>2.(P50)<strong>系统可靠度</strong><br>
串联系统：可靠度为各子系统可靠度的乘积 R=R1R2***Rn</p>
<p>​	并联系统：可靠度分别为R1、R2、...RN表示R=1-(1-R1)(1-R2)***(1-Rn)</p>
<p>3.<strong>中断</strong></p>
<p>根据是否可以被屏蔽，可将中断分为两大类：不可屏蔽中断和可屏蔽中断</p>
<p>不可屏蔽中断源一旦提出请求，CPU必须无条件响应，而对可屏蔽中断源的请求，CPU可以响应，也可以不响应。</p>
<p>典型的非屏蔽中断的例子就是电源掉电，一旦出现，必须立即无条件地响应</p>
<p>典型的可屏蔽中断源的例子是打印机中断</p>
<ol start="4">
<li></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">逻</mi><mi mathvariant="normal">辑</mi><mi mathvariant="normal">异</mi><mi mathvariant="normal">或</mi><mo>(</mo><mi mathvariant="normal">相</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">为</mi><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">为</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">A \oplus B 表示逻辑异或 (相同为0,不同为1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">逻</span><span class="mord cjk_fallback">辑</span><span class="mord cjk_fallback">异</span><span class="mord cjk_fallback">或</span><span class="mopen">(</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">为</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">为</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>6.计算机系统的运算速度受多种因素的影响。</p>
<p>8-9.<strong>计算机病毒</strong>可分为文件型计算机病毒、引导性计算机病毒、宏病毒和目录型计算机病毒。</p>
<p>文件型计算机病毒感染可执行文件（包括EXE和COM文件）</p>
<p>引导性计算机病毒影响软盘和硬盘的引导扇区。</p>
<p>目录型计算机病毒能够修改硬盘上存储的所有文件的地址。</p>
<p>宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等。</p>
<p>10.我国授予专利权采用先申请原则。</p>
<p>11.知识产权（P596）</p>
<p>​	公民为完成法人或其他组织工作任务所创作的产品是职务作品。</p>
<p>一般职务作品的著作权由作者所有</p>
<p>特殊职务作品是利用法人或其他组织的物质技术条件创作，作者享有署名权，其他权利由法人或非法人单位享有。</p>
<p>12-14.</p>
<p>MEPG是Moving Picture Expert Group的简称</p>
<p>标准包括MPEG-1、MPEG-2和MPEG-4主要针对音视频编码技术</p>
<p>MPEG-7是多媒体内容描述接口标准，MPEG-21是多媒体应用框架标准</p>
<p>VCD使用了MPEG-1标准作为音视频信息压缩编码方案</p>
<p>MPEG-2标准被应用于DVD中</p>
<p>15.基于构件的软件开发，强调在构建软件系统时复用已有的软件”构件“，需要针对新系统的需求对构件进行合格线检验、适应性修改，然后集成到新系统中。</p>
<p>16.面向对象</p>
<p>面向对象的软件开发，通常有面向对象分析、面向对象设计、面向对象实现</p>
<ul>
<li>面向对象分析是为了获得应用问题的理解，主要任务是抽取和整理用户需求并建立问题域精准模型。</li>
<li>面向对象设计采用协作的对象、对象的属性和方法说明软件解决方案的一种方式</li>
<li>面向对象实现主要采用面向对象程序设计语言实现系统</li>
<li>面向对象预测是根据规范说明来验证系统设计的正确性。</li>
</ul>
<p>17.白盒测试也称结构测试</p>
<p>根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和过程进行测试，检查是否满足设计的需要。</p>
<p>18-19PERT图参照本书292页</p>
<figure data-type="image" tabindex="1"><img src="G:%5C%E4%B8%8A%E4%BC%A0%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%88%86%E6%9E%90%5CPERT%E5%9B%BE%EF%BC%88%E5%B7%A5%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%9B%BE%EF%BC%89.jpg" alt="" loading="lazy"></figure>
<p>22.中间代码是与具体的机器无关</p>
<ul>
<li>可以将不同的高级程序语言翻译成同一种中间代码。由于与具体机器无关，</li>
<li>使用中间代码有利于进行与机器无关的优化处理</li>
<li>以提高编译程序的可编译性</li>
</ul>
<ol start="20">
<li></li>
</ol>
<p>16位补码为FFFFh ,FFFFh=1111 1111 1111 1111(补码)=1000 0000 0000 0001（原码）</p>
<p>24.死锁</p>
<p>系统同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。</p>
<p>例如， m=5, n=3, h=3若系统釆用的分配策略是轮流地为每个进程分配，则第一轮系统先为每个进 程分配一台，还剩下两台；第二轮系统再为两个进程各分配一台，此时，系统中已无可供分配 的资源，使得各个进程都处于等待状态导致系统发生死锁。</p>
<p>25-26.</p>
<p>局部性原理</p>
<p>(1) 时间局部性。如果程序中的某条指令被执行，则不久以后该指令可能再次执行；如果某数据被访问过者，不久以后该数据可能再次被访问。</p>
<p>(2) 空间局限性。一旦程序访问了某个存储单元，在不久之后其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p>
<figure data-type="image" tabindex="2"><img src="G:%5C%E4%B8%8A%E4%BC%A0%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5C%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%88%86%E6%9E%90%5C%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%EF%BC%88%E8%99%9A%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%89.jpg" alt="页式地址变换（虚地址转换为内存地址的计算方法）" loading="lazy"></figure>
<p>27-28.</p>
<p>29.配置数据库一般包括开发库、受控库和产品库。</p>
<p>31.能力成熟模型CMMI是CMM模型的最新版本，CMMI共有6个（0~5）能力等级，对应未完成级、已执行级、已管理级、已定义级、量化管理级、优化级。</p>
<ul>
<li>能力等级0指未执行过程，表明过程域的一个或多个特定目标没有被满足；</li>
<li>能力等级1值通过转化可识别的输入工作产品，关注与过程域的特定目标完成；</li>
<li>能力等级2值过程作为已定义的过程制度化，过程的组织级标准化和部署</li>
<li>能力等级3作为已定义的过程制度化，过程的组织级标准化和部署；</li>
<li>能力等级4过程作为定量管理的过程制度化</li>
<li>能力等级5指过程作为优化的过程制度化，能够很好的执行且持续得到改进</li>
</ul>
<p>32.统一过程（UP）定义了初启阶段、进化阶段、构建阶段、移交阶段和产生阶段。</p>
<ul>
<li>初启阶段的里程碑是生命周期目标</li>
<li>精化阶段的里程碑是生命周期架构</li>
<li>构建阶段的里程碑是初始运作功能</li>
<li>移交阶段的里程碑是产品发布。</li>
</ul>
<ol start="34">
<li></li>
</ol>
<p>软件配置管理是一组管理整个软件周期各阶段中变更得活动，主要包括变更标识、变更控制和版本控制。</p>
<ol start="35">
<li></li>
</ol>
<ul>
<li>单元测试侧重模块中的内部逻辑和数据结构。</li>
<li>集成测试需要模块按系统设计说明书的要求组合起来进来测试</li>
</ul>
<ol start="36">
<li></li>
</ol>
<p>McCabe度量法是一种基于程序流的复杂性度量方法</p>
<p>V(G)=m-n+2 计算环路复杂度</p>
<p>m是图中弧的个数，n是图中的结点数</p>
<p>37.存在多种继承的概念，但不同的程序设计语言可以自己的规定。</p>
<p>38-40.</p>
<p>不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）</p>
<p>绑定是在编译时进行的，叫做静态绑定。</p>
<p>动态绑定则是在运行是进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。</p>
<ol start="41">
<li></li>
</ol>
<p>面向对象分析包括五个活动：认定对象、组织对象、描述对象间的相互关系、定义对象的操作、定义对象的内部信息。</p>
<p>认定对象：按自然存在的实体确定对象。</p>
<p>组织对象：分析对象间的关系。</p>
<p>描述对象的相互作用是：描述出个对象在应用系统中的关系。</p>
<p>43-44. 45-47.</p>
<p>抽象工程设计模式的意图是提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。</p>
<p>常见情形：一个系统要独立于其产品的创建、组合和表示时；</p>
<p>​	一个系统要由多个产品系列中的一个来配置时；</p>
<p>UML中类与类，已经类与接口，接口与接口的关系有：**泛化（generalization），关联（association），依赖（dependency），实现（realization）**这几种。</p>
<p>泛化（generalization）关系时<strong>指一个类（子类、子接口）继承另外一个类（称为父类、父接口）的功能，并可以增加它自己新功能的能力</strong></p>
<figure data-type="image" tabindex="3"><img src="https://images0.cnblogs.com/blog2015/531894/201506/121155171299723.png" alt="" loading="lazy"></figure>
<p>实现（realization）是指<strong>一个class实现interface接口（一个或者多个）</strong></p>
<figure data-type="image" tabindex="4"><img src="https://images0.cnblogs.com/blog2015/531894/201506/121155320982385.png" alt="" loading="lazy"></figure>
<p>依赖（dependency）关系表示<strong>类与类之间的连接</strong>，表示一个类依赖于另外一个类的定义，<strong>依赖关系时是单向的</strong>。简单理解就是类A使用到了类B，这种依赖具有偶然性、临时性，是<strong>非常弱的关系</strong>。但是类B的变化会影响到类A。举个例子，如某人要过河，则人与船的关系就是依赖，人过河之后，与船的关系就解除了，因此是一种弱的连接。在代码层面，为类B作为参数被类A在某个方法中使用。</p>
<p>在java中，依赖表现为：<strong>局部变量，方法中的参数和对静态方法的调用</strong>。</p>
<figure data-type="image" tabindex="5"><img src="https://images0.cnblogs.com/blog2015/531894/201506/121355216292309.png" alt="" loading="lazy"></figure>
<p>关联（association）关系表示<strong>类与类之间的连接</strong>，它使得一个类知道另外一个类的属性和方法。</p>
<p>关联可以使用单箭头表示单向关联，关联有两个端点，每个端点可以有一个基数，表示这个关联的类可以有几个实例。</p>
<p>0..1 表示可以有0个或者1个实例</p>
<p>0..* 表示对实例的数目没有限制</p>
<p>1   表示只能有一个实例</p>
<p>1..* 表示至少有一个实例</p>
<p>关联关系体现的是两个类，或者类与接口之间的<strong>强依赖关系</strong>，不是偶然性的，也不是临时性的，而是一种长期性，相对平等的关系，表现在代码层面，为被关联的类B以类属性的形式出现在类A中，也可能是关联类A引用了被关联类B的全局变量。</p>
<p>在Java中，<strong>关联关系是使用实例变量来实现的</strong></p>
<figure data-type="image" tabindex="6"><img src="https://images0.cnblogs.com/blog2015/531894/201506/121355508489015.png" alt="" loading="lazy"></figure>
<p>聚合（aggregation）是<strong>关联关系的特例</strong>，是强的关联关系，<strong>聚合是整个与个体的关系</strong>，<strong>即has-a关系，此时整体和部分是可以分离的</strong>，他们具有各自的生命周期，部分可以属于多个对象，也可以被多个对象共享；比如计算机和CPU，公司与员工的关系；在代码层面聚合与关联是一致的，只能从语义上来区分。</p>
<p>聚合关系也是使用实例变量来实现的，在java语法上区分不出关联和聚合，关联关系中类出于一个层次，而聚合则明显的在两个不同的层次。</p>
<figure data-type="image" tabindex="7"><img src="https://images0.cnblogs.com/blog2015/531894/201506/121356046914120.png" alt="" loading="lazy"></figure>
<p>组合（compostion）也是关联关系的一种特例，<strong>体现的是一种contain-a关系</strong>，比聚合更强，是一种强聚合关系。它同样体现整体与部分的关系，<strong>但此时整体与部分是不可分的</strong>，整体生命周期的结束也意味着部分生命周期的结束，反之亦然。<strong>如大脑和人类</strong>。</p>
<p>体现在代码层面与关联时一致的，只能从语义来区分。</p>
<p>组合与聚合几乎完全相同，唯一区别就是对于组合，“部分”不同脱离“整体”单独存在，其生命周期应该是一致的。</p>
<figure data-type="image" tabindex="8"><img src="https://images0.cnblogs.com/blog2015/531894/201506/121356148635113.png" alt="" loading="lazy"></figure>
<p>总结：</p>
<p>主要是关联关系的细化需要注意强弱，由若到强分别是 依赖 &lt; 关联 &lt; 聚合 &lt; 组合</p>
<blockquote>
<p><a href="https://www.cnblogs.com/itplay/p/10671715.html">UML中常用引用关系详解</a></p>
</blockquote>
<p>48.编译和解释是语言处理的两种基本方式。</p>
<p>解释过程直接执行源程序或源程序的内部形式。</p>
<ul>
<li>在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不在参与目标程序的执行过程；而编译器则则需将源程序翻译成独立的目标程序。</li>
<li>而在解释方式下，解释程序和源程序要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序。</li>
</ul>
<p>49.HTML（Hypertext Marked Language）超文本标记语言</p>
<p>​	XML（Extensible Markup Language）可扩展的标记语言</p>
<p>​	WML（Wireless Markup Language)WAP的标记语言</p>
<p>51.需求分析阶段的任务是：对现实世界要处理的对象（组织、部门、企业等）进行详细调查。在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理办法。</p>
<p>逻辑设计阶段的任务 关系模式进一步的规范化处理。</p>
<p>根据规范化理论对关系模式进行分解，以消除冗余和更新异常。</p>
<p>53-56.<em>有损连接、函数依赖</em></p>
<p>57.二分查找 对其进行二分查找的判定树的高度为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>⌋</mo><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mo>(</mo><mi mathvariant="normal">与</mi><mi mathvariant="normal">具</mi><mi mathvariant="normal">有</mi><mi>n</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">完</mi><mi mathvariant="normal">全</mi><mi mathvariant="normal">二</mi><mi mathvariant="normal">叉</mi><mi mathvariant="normal">树</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">样</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\lfloor log_{2}n \rfloor+1\\(与具有n个结点的完全二叉树一样)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">与</span><span class="mord cjk_fallback">具</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">样</span><span class="mclose">)</span></span></span></span></span></p>
<p>58.<em>三角矩阵</em></p>
<p>59.最优二叉树（哈夫曼树）</p>
<p>最优二叉树中只有度为2和0的结点，因此，其结点总数为2n-1</p>
<p>60.对于函数的递归调用于返回，一定是后被调用执行的先返回。</p>
<p>61.当序列基本有序，直接插入排序过程中元素比较次数的较少，当序列为逆序是，元素的比较次数最多。</p>
<p>62.哈希表中</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">记</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\alpha = \frac{表中装入的记录数}{表的长度}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>63.二叉排序树</p>
<p>若插入的关键字大于树根，则插入到右子树，若小于树根，则插入到左子树上，若为空树，则作为树根结点。</p>
<ol start="69">
<li>&lt;malito&gt;标签定义一个指向电子邮箱地址的超级链接，通过该链接可以在Internet中发送电子邮件。</li>
<li>POP默认的TCP端口是110</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2009年下半年软件设计师错题分析]]></title>
        <id>https://syl2017.github.io/post/2009-nian-xia-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/</id>
        <link href="https://syl2017.github.io/post/2009-nian-xia-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/">
        </link>
        <updated>2020-05-12T07:49:54.000Z</updated>
        <content type="html"><![CDATA[<p>1.CPU是计算机的控制中心，主要由运算器、控制器、寄存器组和内部总线等部件组成。</p>
<p>控制器由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成，它是发布命令的“决策机构”，即完成协调和指挥整个计算机系统的操作。它的主要功能有：从内存中取出一条指令，并指出下一条指令在内存中的位置；对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作；指挥并控制CPU、内存和输入输出设备之间数据的流动。</p>
<p>程序计数器（PC)是专用寄存器，具有寄存信息和计数两种功能，又称为指令计数器，在程序开始执行前，将程序的起始地址送入PC,该地址在程序加载到内存时确定，因此PC的初始内容即是程序第一条指令的地址。执行指令时，CPU将自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序执行的，因此修改的过程通常只是简单地对PC加1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出 的直接转移的地址得到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 2009上半年软件设计师错题分析]]></title>
        <id>https://syl2017.github.io/post/2009-shang-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/</id>
        <link href="https://syl2017.github.io/post/2009-shang-ban-nian-ruan-jian-she-ji-shi-cuo-ti-fen-xi/">
        </link>
        <updated>2020-05-12T07:17:25.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li></li>
</ol>
<p>海明码是一种多重（复式）奇偶检错编码</p>
<p>海明码的一项基本考虑是确定最少校验位数。若考虑位数k，考虑长度为n位的信息，若附加了k个校验位，则所发送的总长度为n+k。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果可以表示成一个k位的二进制，他可以确定最多2<sup>k</sup>种不同状态。这些状态必有一个其所有奇偶测试都是真的，剩下2<sup>k</sup>-1中状态可以用来判定误码的位置  $ 2^k-1 \geqq n+k</p>
<p>2.硬盘容量分为非格式化容量和格式化容量</p>
<p>​	非格式化容量=面数*（磁道数/面） * 内圆周长 * 最大位密度</p>
<p>​	格式化容量 = 面数 * （磁道数/面） * （扇区数/道） * （字节数/扇区）</p>
<ol start="3">
<li></li>
</ol>
<p>存储器所处的位置可分为内存和外存</p>
<p>按构成原料的材料可分为磁存储器、半导体和光存储器</p>
<p>按工作方式可分为读写存储器和只读存储器</p>
<p>按访问方式可分为地址访问的存储器和按内容访问的存储器。</p>
<p>按寻址方式可分为随机存储器、顺序存储器和直接存储器</p>
<p>相连存储器是一种按内容访问的存储器</p>
<p>4.总线的分类</p>
<p>按总线上所传送的内容分为数据总线、地址总线和控制总线。</p>
<ol start="5">
<li></li>
</ol>
<p>移码表示法是X上增加一个偏移量来定义，常用于表示浮点数中的阶码。</p>
<p>机器字长为n时，在偏移量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的情况的情况下，只要将补码的符号位取反便可获得相应的移码表示。</p>
<ol start="6">
<li></li>
</ol>
<p>吞吐率和建立时间是使用流水线技术的两个重要指标</p>
<p>吞吐率是指单位时间里流水线处理机流出的结果数。</p>
<p>对指令而言，就是单位时间里执行的指令数。流水线开始工作时，需经过一定时间才能达到最大吞吐量从，这就建立时间。</p>
<p>若m个子过程所用时间一样，均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><mi>m</mi><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_0 =m \Delta t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">m</span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<ol start="7">
<li></li>
</ol>
<p>漏洞扫描系统的原理是根据系统漏洞库对系统可能存在的漏洞进行一一验证。</p>
<p>黑客利用漏斗扫描系统可以发现目标主机的安全漏洞从而有针对的对系统发起攻击；</p>
<p>系统管理利用漏洞扫描系统可以查找系统中存在的漏洞进行修补从而提高系统的可靠性。漏洞扫描系统不能用于发现网络乳清这，用于检测网络乳清这的系统称为如入侵检测系统。</p>
<ol start="8">
<li></li>
</ol>
<p>数字签名技术是不对称加密算法的典型应用。</p>
<p>数据发送发使用自己的私钥对数据校验和其他与数据内容有关的变量进行加密处理，完成对数据的合法“签名”；</p>
<p>数据接受方则利用对方的公钥来解读收到的“数字签名”；</p>
<p>数字签名是对签名真实性的保护</p>
<ol start="10">
<li></li>
</ol>
<p>软件著作权采用“自动保护”原则。</p>
<p>软件著作权自软件开发完成之日产生。</p>
<ol start="12">
<li></li>
</ol>
<p>声音的频率是指声波每秒钟变化的次数，用Hz表示。</p>
<p>人们把频率小于20Hz的声波信号称为亚音信号；</p>
<p>频率范围为20Hz~20kHz的声波信号称为音频型号；</p>
<p>高于20Khz的信号称为超音频信号（超声波）</p>
<ol start="13">
<li></li>
</ol>
<p>JPEG是一个适用范围很广的静态图像数据压缩标准，即可用于灰度图像又可用彩色图像。</p>
<p>MPEG文件格式运动图像压缩算法的国际标准，包括MPEG视频、MPEG音频和MPEG系统三个部分。</p>
<p>AVI是Microsoft公司开发的一种符合RIFF文件规范的数字音频的数字音频与视频文件格式。</p>
<ol start="14">
<li></li>
</ol>
<p>P59</p>
<p>计算机获取模拟信息的过程中首先要进行|A/D变换|。</p>
<ol start="15">
<li></li>
</ol>
<p>敏捷方法进行软件开发。</p>
<p>重构是中重新组织技术，重新审视需求和设计，重新明确地描述他们以符合新的和现有的需求，可以简化构件的设计而无须改变其功能或行为。</p>
<ol start="16">
<li></li>
</ol>
<p>RUP对软件开发过程的描述。RUP应用了角色、活动、制品和工作流4种重要的模型元素。其中角色表述“谁做”，制品表述“做什么”，活动表述“怎么做”，工作流表述“什么时候做”。</p>
<p>-&gt; 2010上半年设计师  第18题PERT</p>
<ol start="17">
<li></li>
</ol>
<p><strong>软件风险</strong>一般包括<strong>不确定性</strong>和<strong>损失</strong>两个<strong>特性</strong></p>
<p>不确定性是指风险可能发生，也可能不发生；</p>
<p>损失是当风险确实发生时，会引发的不希望的后果和损失。</p>
<p>救火和危机管理是对不适合但经常采用的<strong>软件风险管理策略</strong>*。</p>
<p>已知风险和未知风险是对<strong>软件风险进行分类</strong>的一种方式。</p>
<p>员工和预算是在识别<strong>软件风险需要识别的因素</strong>。</p>
<ol start="21">
<li></li>
</ol>
<p>反编译通常不能把可执行文件还原成高级语言源代码，只能转化成功能上等价的汇编程序。</p>
<ol start="25">
<li></li>
</ol>
<p>先来先服务是谁先请求先满足谁的请求，而最短寻找时间优先是根据当前磁臂到要请求访问磁道的距离，谁短满足谁的请求，故先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运动方向。</p>
<ol start="26">
<li></li>
</ol>
<p>死锁，系统同类资源分配不当会引起死锁。一般情况下，若系统中有m个单位的存储器资源，它被n个进程使用，当每个进程都要求w个单位的存储器资源，当m&lt;nw时，可能会引起死锁。</p>
<ol start="28">
<li></li>
</ol>
<p>CMM的基本概念。</p>
<p>建立基本的项目管理和实践来跟踪项目费用、进度和功能特性为<strong>可重复级的核心</strong>；</p>
<p>使用标准开发过程构件系统为<strong>已定义级的核心</strong>；</p>
<p>管理层寻求更主动地对应系统的开发问题为<strong>已管理级的核心</strong>；</p>
<p>连续地监督和改进标准化的系统开发过程为<strong>优化级的核心</strong>。</p>
<ol start="30">
<li></li>
</ol>
<p>RUP每个阶段产生的制品</p>
<p><strong>初启阶段</strong>结束时产生一个构想文档、一个有关用例模型的调查、一个初始的业务用例、一个早期的风险评估和一个可以显示阶段和迭代的项目计划等制品；</p>
<p><strong>精华阶段</strong>结束时产生一个补充需求分析、一个软件架构描述和一个可执行的架构原型等制品；</p>
<p><strong>构建阶段</strong>结束时的成果是一个准备交到最终用户手中的产品，包括最具有最初运作能力的在适当的平台上集成的软件产品、用户手册和对当前版本的描述</p>
<p><strong>移交阶段</strong>结束时产生移交给用户产品发布版本。</p>
<ol start="31">
<li></li>
</ol>
<p>ISO/IEC 9126 软件质量度量模型中的质量特性。效率质量特性包括时间特性和资源特性两个质量子特性。</p>
<ol start="32">
<li></li>
</ol>
<p>McCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，他基于一个程序模块的程序吐中环路的个数。计算有向图G的环路复杂性的公式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>(</mo><mi>G</mi><mo>)</mo><mo>=</mo><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">V(G)=m-n+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>,其中V（G）是有向图G中的环路个数，m是G中的有向弧数，n是G中的节点数。</p>
<ol start="33">
<li></li>
</ol>
<p>开发文档。</p>
<p>系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划、系统开发月报以及系统开发总结报告等项目管理文件。</p>
<p>34.软件维护</p>
<p>P281</p>
<p>软件维护</p>
<p>1.正确性维护。改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</p>
<p>2.适应性维护。适应性维护是指应用软件适应信息技术变化和管理需求变化而进行的修改。</p>
<p>3.完善性维护，这是为扩充功能和改善性能而进行的修改，主要是对指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</p>
<p>4.预防性维护。为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬环境的变化，应主动增加预防性的新的功能。</p>
<p>38-40.</p>
<p>P352</p>
<p>类可以分为三种：实体类、接口类（边界类）和控制类。</p>
<p>实体类的对象表示现实世界中真实的实体。</p>
<p>接口类（边界类）的对象为用户提供一种与系统合作交互的方式。</p>
<p>控制类的对象用来控制活动流，充当协调者。</p>
<ol start="41">
<li></li>
</ol>
<p>2010年上半年错题分析-----&gt;41.</p>
<p>43-45.</p>
<p>装饰模式主要的目的是在无法生成子类的情况下给一个对象动态地增加新的职责；</p>
<p>享元设计模式是共享大量细粒度的对象；</p>
<p>适配器设计模式则是将已有的借口转换为系统希望的借口形式。</p>
<ol start="50">
<li></li>
</ol>
<p>一个文法的语言是该文法能产生的句子的集合。</p>
<p>一个文法产生的句子是从文法开始符号出发推导出的所有终结符号串。</p>
<ol start="51">
<li></li>
</ol>
<p>P473</p>
<p>常见的数据模型有层次模型、网状模型、关系模型和面向对象模型。</p>
<p>(1).层次模型 采用树型结构表示数据与数据见得联系。</p>
<p>(2).网状模型 允许两个结点之间有多种联系（称之为复合联系）。</p>
<p>(3).关系模型 关系数据库系统采用关系模型作为数据的组织方式，表达实体集以及实体集之间的联系</p>
<p>(4).面向对象数据模型 面向对象的方式来设计数据库。</p>
<ol start="52">
<li></li>
</ol>
<p>分解的模式是否与原来的模式等价</p>
<ul>
<li>分解具有无损连接性</li>
<li>分解要保持函数依赖</li>
<li>分解既要无损连接性，又要保持函数依赖。</li>
</ul>
<p>55-56.</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mn>1</mn><mo>&lt;</mo><mn>6</mn></mrow></msub><mo>(</mo><mi>R</mi><mo>×</mo><mi>S</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">集</mi></mrow><annotation encoding="application/x-tex">\pi_{3,4,5}(\sigma_{1&lt;6}(R\times S))的结果集
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">4</span><span class="mpunct mtight">,</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">&lt;</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">集</span></span></span></span></span></p>
<p><strong>广义笛卡尔积（Extended Cartesian Product)</strong></p>
<p>现有关系R和关系S，如下表所示。</p>
<p><strong>关系R</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
</tbody>
</table>
<p><strong>关系S</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
</tbody>
</table>
<p>先求关系R和关系S的广义笛卡儿积RxS。</p>
<p><strong>RxS</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">R.A</th>
<th style="text-align:left">R.B</th>
<th style="text-align:left">R.C</th>
<th style="text-align:left">S.A</th>
<th style="text-align:left">S.B</th>
<th style="text-align:left">S.C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b1</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a1</td>
<td style="text-align:left">b3</td>
<td style="text-align:left">c2</td>
</tr>
<tr>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
<td style="text-align:left">a2</td>
<td style="text-align:left">b2</td>
<td style="text-align:left">c1</td>
</tr>
</tbody>
</table>
<p><strong>选择（Selection）</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mn>1</mn><mo>≥</mo><mn>6</mn></mrow></msub><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{1\geq6}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≥</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>表示选取R关系中第一个属性值大于等于第六个属性的元组。</p>
<p><strong>投影（Projection）</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mi>A</mi></msub><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi_A(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>在关系R中选择若干属性列A组成新的关系。</p>
<ol start="57">
<li></li>
</ol>
<p>哈希表和二叉排序树都可以在查找过程中动态创建，属于动态查找表。</p>
<p>顺序查找表方法按照设定的次序依次与查找表中元素的关键字进行比较，在顺序存储结构和链表结构上都可以实现该查找过程。</p>
<p>二分查找需要对中间元素进行快速定位，在链表结构上无法实现。</p>
<ol start="58">
<li></li>
</ol>
<p>有向图中，若以顶点表示活动，用有向边表示活动之间的优先关系，则称这样的有向图为以顶点表示活动的网（Activity On Vertex Network，AOV）</p>
<p>若在带权有向图G中以顶点表示事件，以有向边表示活动，边上的权值表示该活动持续的时间，则这种带权有向图称为用边表示活动的图（Activity On Edge Network,AOE网）</p>
<p>通常AOE网中列出了完成预定工程计划所需进行的活动、每项活动的计划完成时间、要发生哪些事件以及这些事件和活动间的关系，从而可以分析该项工程是否实际可行并估计工程完成的最短时间，分析哪些活动是影响工程进度的关键。进一步进行人力、物力的调度和分配，以达到缩短工期的目的。</p>
<p>根据生成树的定义，有n个顶点的连通图的生成树恰好有n-1条边。</p>
<ol start="59">
<li></li>
</ol>
<p>二叉排序树具有如下性质：</p>
<ol>
<li>若它的左子树非空，则其左子树上所有节点的关键字均小于根节点的关键字。</li>
<li>若它的右子树非空，则其右子树上所有节点的关键字均大于根节点的关键字。</li>
<li>左、右子树本身就是两颗二叉排序树。</li>
</ol>
<p>二叉排序树是一个有序表，对二叉排序树进行中序遍历，可得到一个关键字递增排序的序列。</p>
<p>构造一颗二叉排序树：从空树开始，每读入一个关键字值，就建立一个新结点。若二叉树非空，则将新结点的关键字与根节点的关键字相比较，如果小于根节点的值，则插入到左子树中，否则插入到右子树中；若二叉排序树为空树，则新结点作为二叉排序树的根节点。</p>
<p>若关键字序列已经有序，则构造出的二叉排序树一定是单枝树。</p>
<p>为了使在二叉排序树上进行的查找操作性能最优，构造二叉排序树需进行平衡化处理，使每个结点左、右子树高度差的绝对值不超过1。</p>
<ol start="60">
<li></li>
</ol>
<p>栈和队列都是操作受限的线性表：栈仅在表尾插入和删除元素，队列仅在表头删除元素、在表尾插入元素。</p>
<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200511202102.png" alt="用线性表模拟入队操作" loading="lazy"></figure>
<ol>
<li>
<p>入队时，新元素在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后，若新元素节点指针为s，则在一般情况下入队操作序列表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">s\rightarrow next=rear\rightarrow next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span>; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">rear\rightarrow next=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">rear=s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>;</p>
</li>
<li>
<p>出队时，讲队头元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>从队列中删除，一般情况下出队操作序列表示为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo separator="true">;</mo><mspace linebreak="newline"></mspace><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo>=</mo><mi>q</mi><mo>→</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mspace linebreak="newline"></mspace><mi>f</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>(</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q=rear\rightarrow next;\\rear \rightarrow next=q \rightarrow next \\free(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200511202103.png" alt="用线性表模拟出队操作" loading="lazy"></figure>
<p>入队时初始化队列为空、出队后队列变为空要进行特殊处理。</p>
<p>入队操作和出队操作均匀队列长度无关，因此时间复杂度都为O(1).</p>
<p>一个线性序列经过队列结构后只能得到与原序列相同的元素序列，而经过一个栈结构后则可以得到多种元素序列。</p>
<p>用两个栈可以模拟一个队列的入队和出队操作。</p>
<ol start="61">
<li></li>
</ol>
<p>一颗完全二叉树除了最后一层外，其他层的节点都是满的，最后一层的节点也必须自左至右排列。</p>
<p>二叉树采用顺序存储结构时，对于编号为i的节点，则有：</p>
<ul>
<li>若i=1时，该节点为根节点，无双亲；</li>
<li>若i&gt;1时，该节点的双亲节点为「i/2」;</li>
<li>若2i<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≦</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\leqq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mrel amsrm">≦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,则节点的双亲节点为2i，否则无左孩子；</li>
<li>若2i+1<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≦</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\leqq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01166em;vertical-align:-0.25583em;"></span><span class="mrel amsrm">≦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,则该节点的则该节点的右孩子编号为2i+1，否则无右孩子。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/20200511202104.png" alt="" loading="lazy"></figure>
<p>可以推到出具有n个节点的完全二叉树的深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">log_2 n +1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>62.广义表是函数式语言中使用的一种数据结构。根据广义表取表头和取表尾的定义，对于广义表L=((x,y,z),a,(u,t,w)),运算head(L)定义为取非空广义表的第一个元素，tail(L)定义为取非空广义表第一个元素剩余元素构成的广义表。</p>
<ol start="64">
<li></li>
</ol>
<p>回溯法的实质是在包含问题的所有解的解空间树中，按照深度优先的策略，从根节点出发搜索解空间树。若进入某子节点的子树后没有找到解（或者需要找到全部解），则需要子节点回退（回溯）至父节点，从而选择其他节点进行搜索。</p>
<p>分治与递归就像一对孪生兄弟，经常同时应用与算法设计之中。分治的思路是将一个难以直接解决的大问题分解成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的，如用分治法来解这类问题，则相同的子问题会不会求解多次，以至于最后的解决原问题需要耗费支出及时间，动态规划算法通常用于求解具有某种最优性质的问题，在这类问题中可能会有许多可行解。每个可行解都对应一个值，我们希望找到具有最优值的那个解。</p>
<p>67.Server2003，路由类型有五种。当windows服务器收到一个ip数据包是先查主机路由，在查网络路由直连网络和远程网络这些路由查找失败时，最后才查找默认路由。</p>
<table>
<thead>
<tr>
<th>路由类型。</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>直连网络id，</td>
<td>用于直连的网络interfaith可以为空。</td>
</tr>
<tr>
<td>远程网络id</td>
<td>用于不直接连接的网络可以通过其他路由器到达这种网络，interfaith字段是本地路由器的ip地址。</td>
</tr>
<tr>
<td>主机路由。</td>
<td>到达特定的主机，路由子网掩码为255.255.255.255。</td>
</tr>
<tr>
<td>默认路由。</td>
<td>无法找到确定路由时使用的路由目标网络和网络掩码都是0.0.0.0。</td>
</tr>
<tr>
<td>持久路由</td>
<td>利用route add -p命令添加的表现，每次初始化时，这种路由都会加入windows的注册表中，同时加入路由表。</td>
</tr>
</tbody>
</table>
<p>68.HTML基本标签的使用alink用于设置正在比鸡种的链接的颜色vlink用于设置使用的链接的颜色background，用于设置背景图片的URL bgcolor用于设置文档整体背景颜色。</p>
<p>69.HTML标记中tr标记的使用。&lt;tr&gt;标记用于定义表格中的一行。&lt;col&gt;标记用于定义表格中一个或多个列的属性值。&lt;td&gt;标记定义表格中的一个单元格。</p>
<p>70.XML语法的基本知识，XML文件的第一行必须是声明该文件是XML文件以及它所使用的XML规范版本，在文件的前面并能够有其他元素或是注释，所有的XML文件必须有一个根元素，XML文件的第一个元素就是根元素。所有XML文档都必须包含一个单独的标记来定义所有其他元素都必须成对的，在根元素嵌套XML文件有且只能有一个根元素，所有的元素都可以有子元素，子元素必须正确地嵌套在父元素中来，在XML中规定所有标志必须成对出现有一个开始标识，就必须有一个结束标志，否则就将被视为错误。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5.抽象工厂]]></title>
        <id>https://syl2017.github.io/post/5chou-xiang-gong-han/</id>
        <link href="https://syl2017.github.io/post/5chou-xiang-gong-han/">
        </link>
        <updated>2020-05-12T07:06:58.000Z</updated>
        <content type="html"><![CDATA[<p>#####5. 抽象工厂</p>
<p>多个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类；每个具体工厂类可创建多个具体产品类的实例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4 .工厂方法]]></title>
        <id>https://syl2017.github.io/post/4-gong-han-fang-fa/</id>
        <link href="https://syl2017.github.io/post/4-gong-han-fang-fa/">
        </link>
        <updated>2020-05-12T07:02:24.000Z</updated>
        <content type="html"><![CDATA[<h5 id="4工厂方法">4.工厂方法</h5>
<p>定义一个创建对象的接口，让其子类决定实例化哪一个类。</p>
<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95A%E5%9B%BE.jpg" alt="" loading="lazy"></figure>
<p>工厂借口：与调用者交互来提供产品</p>
<p>工厂实现：工厂决定如何实例化产品，有多少种产品，就需要多少个具体的工厂实现。</p>
<p>产品借口：定义产品规范</p>
<p>产品实现：实现产品借口的具体类。</p>
<figure data-type="image" tabindex="2"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95B%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>优点：用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</p>
<p>缺点：每次增加一个产品，都需要增加一个具体和对象实现工厂。是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加具体类的依赖。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3.工厂模式 ]]></title>
        <id>https://syl2017.github.io/post/2-5-gong-han-mo-shi-gong-han-fang-fa-chou-xiang-fang-fa/</id>
        <link href="https://syl2017.github.io/post/2-5-gong-han-mo-shi-gong-han-fang-fa-chou-xiang-fang-fa/">
        </link>
        <updated>2020-05-12T06:59:16.000Z</updated>
        <content type="html"><![CDATA[<h5 id="3工厂模式">3.工厂模式</h5>
<p>属于创新型设计模式，通过专门定义一个类来负责其他类的实例。</p>
<figure data-type="image" tabindex="1"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FA%E5%9B%BE.jpg" alt="" loading="lazy"></figure>
<p>工厂角色：负责创建所有逻辑，创建所需对象。</p>
<p>抽象产品角色：所有对象的父类，也可为借口或抽象类。</p>
<p>具体产品：拥有共同父类。</p>
<p>代码实现</p>
<figure data-type="image" tabindex="2"><img src="https://liang-markdonw-pic.oss-cn-shenzhen.aliyuncs.com/img/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FB%E5%9B%BE.jpeg" alt="" loading="lazy"></figure>
<p>优点</p>
<p>根据外界的信息，决定创建那个具体类的对象。用户使用直接创建所需的实例，而无需了解这些对象如何创建以及组织。</p>
<p>缺点</p>
<p>工厂类集中了所有实例的创建逻辑，违背了单一职责，违背了开放封闭原则。</p>
]]></content>
    </entry>
</feed>